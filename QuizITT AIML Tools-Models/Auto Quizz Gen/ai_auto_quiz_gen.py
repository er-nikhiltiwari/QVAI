# -*- coding: utf-8 -*-
"""ai auto quiz gen.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rWHCTsEPQnM8EhMKRvrJgAvJQpYpW2lu

**Updated JSON**
"""

pip install google-generativeai

import google.generativeai as genai
import json
import uuid
import random

genai.configure(api_key="AIzaSyBVZ..............mtosgiH2h8")

model = genai.GenerativeModel("gemini-2.0-flash")

def generate_mcq_questions(subject: str, topic: str, num_questions: int = 5) -> list:
    """
    Generates multiple-choice questions (MCQs) for a given topic.
    """
    prompt = f"""
    Generate {num_questions} multiple-choice questions on the topic '{topic}' in the subject '{subject}'.
    Each question should be structured as a JSON object with the following keys:
    - "questionId": A unique identifier for the question (generate a UUID).
    - "questionText": The text of the question.
    - "options": A list of 4 strings representing the answer options.
    - "correctAnswer": The correct answer string from the options.
    - "explanation": A detailed explanation for the correct answer.
    - "difficulty": The difficulty level of the question, either "easy", "medium", or "hard".

    Ensure the output is a JSON array containing {num_questions} such objects.
    Example format for one question (note: questionId will be a full UUID, not just a number):
    {{
        "questionId": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
        "questionText": "What is the capital of France?",
        "options": ["Berlin", "Madrid", "Paris", "Rome"],
        "correctAnswer": "Paris",
        "explanation": "Paris is the capital and most populous city of France.",
        "difficulty": "easy"
    }}
    """
    try:
        response = model.generate_content(prompt)
        response_text = response.text.replace("```json", "").replace("```", "").strip()
        questions = json.loads(response_text)
        difficulty_levels = ["easy", "medium", "hard"]
        for question in questions:
            question["questionId"] = str(uuid.uuid4())
            question["difficulty"] = random.choice(difficulty_levels)
        return questions
    except json.JSONDecodeError as e:
        print(f"Failed to parse JSON response for MCQ from the model: {e}")
        print(f"Raw response received:\n{response.text}")
        return []
    except Exception as e:
        print(f"An unexpected error occurred during MCQ generation: {e}")
        print(f"Raw response received:\n{response.text}")
        return []

def generate_true_false_questions(subject: str, topic: str, num_questions: int = 5) -> list:
    """
    Generates true or false questions for a given topic.
    """
    prompt = f"""
    Generate {num_questions} true or false questions on the topic '{topic}' in the subject '{subject}'.
    Each question should be structured as a JSON object with the following keys:
    - "questionId": A unique identifier for the question (generate a UUID).
    - "question": The text of the question, phrased as a statement to be evaluated as true or false.
    - "options": A list containing exactly two strings: ["True", "False"].
    - "correctAnswer": The correct answer string, either "True" or "False".
    - "explanation": A detailed explanation for why the statement is true or false.
    - "difficulty": The difficulty level of the question, either "easy", "medium", or "hard".

    Ensure the output is a JSON array containing {num_questions} such objects.
    Example format for one question (note: questionId will be a full UUID, not just a number):
    {{
        "questionId": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
        "question": "The capital of France is Berlin.",
        "options": ["True", "False"],
        "correctAnswer": "False",
        "explanation": "The capital of France is Paris, not Berlin. Berlin is the capital of Germany.",
        "difficulty": "medium"
    }}
    """
    try:
        response = model.generate_content(prompt)
        response_text = response.text.replace("```json", "").replace("```", "").strip()
        questions = json.loads(response_text)
        difficulty_levels = ["easy", "medium", "hard"]
        for question in questions:
            question["questionId"] = str(uuid.uuid4())
            question["options"] = ["True", "False"]
            question["difficulty"] = random.choice(difficulty_levels)
        return questions
    except json.JSONDecodeError as e:
        print(f"Failed to parse JSON response for True/False from the model: {e}")
        print(f"Raw response received:\n{response.text}")
        return []
    except Exception as e:
        print(f"An unexpected error occurred during True/False generation: {e}")
        print(f"Raw response received:\n{response.text}")
        return []

def generate_fill_in_the_blank_questions(subject: str, topic: str, num_questions: int = 5) -> list:
    """
    Generates fill-in-the-blanks questions for a given topic.
    """
    prompt = f"""
    Generate {num_questions} fill-in-the-blanks questions on the topic '{topic}' in the subject '{subject}'.
    Each question should be structured as a JSON object with the following keys:
    - "questionId": A unique identifier for the question (generate a UUID).
    - "question": The text of the question with a blank indicated by three underscores (___).
    - "options": A list of 4 strings representing the possible words/phrases to fill the blank, including the correct answer.
    - "correctAnswer": The correct word/phrase that fills the blank.
    - "explanation": A detailed explanation for the correct answer.
    - "difficulty": The difficulty level of the question, either "easy", "medium", or "hard".

    Ensure the output is a JSON array containing {num_questions} such objects.
    Example format for one question (note: questionId will be a full UUID, not just a number):
    {{
        "questionId": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
        "question": "The capital of France is ___.",
        "options": ["Berlin", "Madrid", "Paris", "Rome"],
        "correctAnswer": "Paris",
        "explanation": "Paris is the capital and most populous city of France.",
        "difficulty": "easy"
    }}
    """
    try:
        response = model.generate_content(prompt)
        response_text = response.text.replace("```json", "").replace("```", "").strip()
        questions = json.loads(response_text)
        difficulty_levels = ["easy", "medium", "hard"]
        for question in questions:
            question["questionId"] = str(uuid.uuid4())
            question["difficulty"] = random.choice(difficulty_levels)
        return questions
    except json.JSONDecodeError as e:
        print(f"Failed to parse JSON response for Fill-in-the-Blank from the model: {e}")
        print(f"Raw response received:\n{response.text}")
        return []
    except Exception as e:
        print(f"An unexpected error occurred during Fill-in-the-Blank generation: {e}")
        print(f"Raw response received:\n{response.text}")
        return []

def generate_match_the_following_questions(subject: str, topic: str, num_questions: int = 5) -> list:
    """
    Generates 'match the following' questions for a given topic.
    """
    prompt = f"""
    Generate {num_questions} 'match the following' questions on the topic '{topic}' in the subject '{subject}'.
    Each question should be structured as a JSON object with the following keys:
    - "questionId": A unique identifier for the question (generate a UUID).
    - "questionText": An introductory text for the matching question (e.g., "Match the following:").
    - "left": A list of strings for the left column (terms/concepts).
    - "right": A list of strings for the right column (definitions/explanations/matches).
    - "matches": A list of JSON objects, where each object has "left" (from left column), "correctRight" (from right column), and "explanation" to indicate the correct pairing and explanation.
    - "difficulty": The difficulty level of the question, either "easy", "medium", or "hard".

    Ensure that the number of items in 'left' and 'right' is the same for each question, and that 'right' items are sufficiently shuffled or varied so the correct match isn't obvious by order.
    The number of items in left and right should be between 4 and 6.

    Ensure the output is a JSON array containing {num_questions} such objects.
    Example format for one question (note: questionId will be a full UUID, not just a number):
    {{
        "questionId": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
        "questionText": "Match the following capitals to their countries:",
        "left": ["France", "Germany", "Italy", "Spain"],
        "right": ["Madrid", "Rome", "Berlin", "Paris"],
        "matches": [
            {{"left": "France", "correctRight": "Paris", "explanation": "Paris is the capital of France."}},
            {{"left": "Germany", "correctRight": "Berlin", "explanation": "Berlin is the capital of Germany."}},
            {{"left": "Italy", "correctRight": "Rome", "explanation": "Rome is the capital of Italy."}},
            {{"left": "Spain", "correctRight": "Madrid", "explanation": "Madrid is the capital of Spain."}}
        ],
        "difficulty": "medium"
    }}
    """
    try:
        response = model.generate_content(prompt)
        response_text = response.text.replace("```json", "").replace("```", "").strip()
        questions = json.loads(response_text)
        difficulty_levels = ["easy", "medium", "hard"]
        for question in questions:
            question["questionId"] = str(uuid.uuid4())
            if "columnA" in question:
                question["left"] = question.pop("columnA")
            if "columnB" in question:
                question["right"] = question.pop("columnB")
            if "correctMatches" in question:
                new_matches = []
                for match in question["correctMatches"]:
                    new_match = {"left": match["term"], "correctRight": match["match"], "explanation": match.get("explanation", "")}
                    new_matches.append(new_match)
                question["matches"] = new_matches
                del question["correctMatches"]
            question["difficulty"] = random.choice(difficulty_levels)
        return questions
    except json.JSONDecodeError as e:
        print(f"Failed to parse JSON response for Match the Following from the model: {e}")
        print(f"Raw response received:\n{response.text}")
        return []
    except Exception as e:
        print(f"An unexpected error occurred during Match the Following generation: {e}")
        print(f"Raw response received:\n{response.text}")
        return []

def generate_flashcard_questions(subject: str, topic: str, num_questions: int = 5) -> list:
    """
    Generates 'Flash Card' questions on a given topic and subject.
    """
    prompt = f"""
    Generate {num_questions} flashcard-type questions on the topic '{topic}' in the subject '{subject}'.
    Each flashcard should be structured as a JSON object with the following keys:
    - "questionId": A unique identifier for the question (generate a UUID).
    - "term": The "question" or prompt for the flashcard.
    - "definitionOptions": A list of 4 strings representing possible answer choices, one of which is the correct answer.
    - "correctDefinition": The correct answer string from the definitionOptions list.
    - "explanation": A detailed explanation for the correct answer.
    - "difficulty": The difficulty level of the question, either "easy", "medium", or "hard".

    Ensure the output is a JSON array containing {num_questions} such objects.
    Example format for one flashcard (note: questionId will be a full UUID, not just a number):
    {{
        "questionId": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
        "term": "What is the chemical symbol for water?",
        "definitionOptions": ["H2O", "CO2", "O2", "N2"],
        "correctDefinition": "H2O",
        "explanation": "H2O. Water is a chemical compound with the chemical formula H2O. A water molecule contains one oxygen and two hydrogen atoms connected by covalent bonds.",
        "difficulty": "easy"
    }}
    """
    try:
        response = model.generate_content(prompt)
        response_text = response.text.replace("```json", "").replace("```", "").strip()
        questions = json.loads(response_text)
        difficulty_levels = ["easy", "medium", "hard"]
        for question in questions:
            question["questionId"] = str(uuid.uuid4())
            if "front" in question:
                question["term"] = question.pop("front")
            if "options" in question:
                question["definitionOptions"] = question.pop("options")
            if "back" in question and "explanation" not in question:
                question["explanation"] = question.pop("back")
            if "correctAnswer" in question:
                question["correctDefinition"] = question.pop("correctAnswer")
            question["difficulty"] = random.choice(difficulty_levels)
        return questions
    except json.JSONDecodeError as e:
        print(f"Failed to parse JSON response for Flashcard from the model: {e}")
        print(f"Raw response received:\n{response.text}")
        return []
    except Exception as e:
        print(f"An unexpected error occurred during Flashcard generation: {e}")
        print(f"Raw response received:\n{response.text}")
        return []

def main():
    print("Automated Comprehensive Quizzes Generator")

    try:
        with open("NEET_Bio_Syllabus.json", "r") as f:
            input_data = json.load(f)

        output_data = {"subjects": []}

        subject_name = input_data.get("Subject")
        chapters_input = input_data.get("Chapters", [])

        if not subject_name:
            raise ValueError("Subject not found in JSON input.")

        subject_data = {
            "subject_name": subject_name,
            "chapters": []
        }
        output_data["subjects"].append(subject_data)

        for chapter_idx, chapter in enumerate(chapters_input):
            chapter_name = chapter.get("Chapter")
            subtopics_input = chapter.get("Subtopics", [])

            if chapter_name and subtopics_input:
                chapter_data = {
                    "chapter_id": chapter_idx + 1,
                    "chapter_name": chapter_name,
                    "subtopics": [],
                }

                for subtopic_idx, subtopic in enumerate(subtopics_input):
                    print(f"\nGenerating questions for Chapter: {chapter_name}, Subtopic: {subtopic}")

                    questions_for_subtopic = {
                        "mcq": [],
                        "fillInTheBlanks": [],
                        "trueFalse": [],
                        "matchthefollowing": [],
                        "flashcard": []
                    }

                    mcq_questions = generate_mcq_questions(subject_name, subtopic)
                    if mcq_questions:
                        questions_for_subtopic["mcq"].extend(mcq_questions)
                        print(f"   Generated {len(mcq_questions)} MCQ questions.")
                    else:
                        print(f"   Failed to generate MCQ questions for {subtopic}.")

                    true_false_questions = generate_true_false_questions(subject_name, subtopic)
                    if true_false_questions:
                        questions_for_subtopic["trueFalse"].extend(true_false_questions)
                        print(f"   Generated {len(true_false_questions)} True/False questions.")
                    else:
                        print(f"   Failed to generate True/False questions for {subtopic}.")

                    fill_in_the_blank_questions = generate_fill_in_the_blank_questions(subject_name, subtopic)
                    if fill_in_the_blank_questions:
                        questions_for_subtopic["fillInTheBlanks"].extend(fill_in_the_blank_questions)
                        print(f"   Generated {len(fill_in_the_blank_questions)} Fill-in-the-Blank questions.")
                    else:
                        print(f"   Failed to generate Fill-in-the-Blank questions for {subtopic}.")

                    match_the_following_questions = generate_match_the_following_questions(subject_name, subtopic, num_questions=4)
                    if match_the_following_questions:
                        questions_for_subtopic["matchthefollowing"].extend(match_the_following_questions)
                        print(f"   Generated {len(match_the_following_questions)} Match the Following questions.")
                    else:
                        print(f"   Failed to generate Match the Following questions for {subtopic}.")

                    flashcard_questions = generate_flashcard_questions(subject_name, subtopic)
                    if flashcard_questions:
                        questions_for_subtopic["flashcard"].extend(flashcard_questions)
                        print(f"   Generated {len(flashcard_questions)} Flashcard questions.")
                    else:
                        print(f"   Failed to generate Flashcard questions for {subtopic}.")

                    if any(questions_for_subtopic.values()):
                        subtopic_data = {
                            "subtopic_id": subtopic_idx + 1,
                            "subtopic_name": subtopic,
                            "questions": questions_for_subtopic,
                        }
                        chapter_data["subtopics"].append(subtopic_data)
                    else:
                        print(f"No questions generated for Subtopic: {subtopic}. Skipping this subtopic.")

                if chapter_data["subtopics"]:
                    subject_data["chapters"].append(chapter_data)
                else:
                    print(f"Skipping Chapter {chapter_name} because no valid subtopics with questions were found.")

        output_filename = f"{subject_name}_all_quizzes.json".replace(" ", "_").lower()
        with open(output_filename, "w") as outfile:
            json.dump(output_data, outfile, indent=4)

        print(f"\nSuccessfully generated and saved all quiz data to '{output_filename}'.")

    except FileNotFoundError:
        print("Error: 'Bio_syllabus.json' not found. Please ensure the file exists in the same directory.")
    except json.JSONDecodeError:
        print("Error: Invalid JSON format in 'Bio_syllabus.json'.")
    except ValueError as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    main()