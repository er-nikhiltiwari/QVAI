!pip install PyPDF2 google-generativeai gradio python-dotenv openai pypdf python-docx

!pip install google-generativeai gradio PyPDF2 python-docx python-pptx pytesseract Pillow

import google.generativeai as genai
import gradio as gr
import os
from PyPDF2 import PdfReader
import io

try:
    from docx import Document
except ImportError:
    print("Warning: 'python-docx' not found. DOCX file support will be unavailable.")
    Document = None

try:
    from pptx import Presentation
except ImportError:
    print("Warning: 'python-pptx' not found. PPTX file support will be unavailable.")
    Presentation = None

try:
    import pytesseract
    from PIL import Image
except ImportError:
    print("Warning: 'pytesseract' or 'Pillow' not found. Image (OCR) support will be unavailable.")
    print("Ensure Tesseract OCR engine is also installed on your system for image processing.")
    pytesseract = None
    Image = None

API_KEY = "AIzaSyDD1ZWZrm1J3uEtMe8SMRRXlnStyZnppvQ"

if API_KEY == "YOUR_GEMINI_API_KEY" or not API_KEY:
    raise ValueError("Please replace 'YOUR_GEMINI_API_KEY' with your actual API key in the script.")

genai.configure(api_key=API_KEY)

model = genai.GenerativeModel(
    'gemini-2.0-flash',
    system_instruction="Your responses should be concise, direct, and between 120 and 200 words. Do not exceed this word limit. and also You should only response to only the Educational related questions, answers, explanations and FAQs. Answer generated by you must be always educational"
)

def extract_text_from_pdf(pdf_file_content):
    """Extracts text from a PDF file object."""
    try:
        reader = PdfReader(io.BytesIO(pdf_file_content))
        text = ""
        for page_num in range(len(reader.pages)):
            text += reader.pages[page_num].extract_text() or ""
        return text
    except Exception as e:
        return f"Error processing PDF: {e}"

def extract_text_from_txt(txt_file_content):
    """Extracts text from a TXT file content."""
    try:
        return txt_file_content.decode('utf-8')
    except Exception as e:
        return f"Error processing TXT: {e}"

def extract_text_from_docx(docx_file_path):
    """Extracts text from a DOCX file."""
    if Document is None:
        return "Error: 'python-docx' library not installed. Cannot process DOCX files."
    try:
        doc = Document(docx_file_path)
        full_text = []
        for para in doc.paragraphs:
            full_text.append(para.text)
        return '\n'.join(full_text)
    except Exception as e:
        return f"Error processing DOCX: {e}"

def extract_text_from_pptx(pptx_file_path):
    """Extracts text from a PPTX file."""
    if Presentation is None:
        return "Error: 'python-pptx' library not installed. Cannot process PPTX files."
    try:
        prs = Presentation(pptx_file_path)
        full_text = []
        for slide in prs.slides:
            for shape in slide.shapes:
                if hasattr(shape, "text"):
                    full_text.append(shape.text)
        return '\n'.join(full_text)
    except Exception as e:
        return f"Error processing PPTX: {e}"

def extract_text_from_image(image_file_path):
    """Extracts text from an image file using OCR."""
    if pytesseract is None or Image is None:
        return "Error: 'pytesseract' or 'Pillow' not installed, or Tesseract OCR engine missing. Cannot process image files."
    try:
        img = Image.open(image_file_path)
        text = pytesseract.image_to_string(img)
        return text
    except Exception as e:
        return f"Error processing image (OCR): {e}. Make sure Tesseract is installed and configured."


def get_document_context(file_path):
    """Reads the content of a document, supporting multiple types."""
    extension = os.path.splitext(file_path)[1].lower()

    if extension == '.pdf':
        with open(file_path, "rb") as f:
            return extract_text_from_pdf(f.read())
    elif extension == '.txt':
        with open(file_path, "rb") as f:
            return extract_text_from_txt(f.read())
    elif extension == '.docx':
        return extract_text_from_docx(file_path)
    elif extension == '.pptx':
        return extract_text_from_pptx(file_path)
    elif extension in ['.jpg', '.jpeg', '.png', '.img']:
        return extract_text_from_image(file_path)
    else:
        return "Unsupported document type. Please upload a .txt, .docx, .pptx, .pdf, or an image file (.jpg, .png, .img)."

chat_history = []
document_context = ""

def generate_response(user_message, history):
    """Generates a response using the Gemini model, incorporating document context."""
    global document_context
    global chat_history

    full_query = user_message
    if document_context:
        full_query = f"Based on the following document content:\n\n{document_context}\n\nAnd the user's query: {user_message}"

    try:
        prompt_with_history = ""
        for human, ai in history:
            prompt_with_history += f"Human: {human}\nAI: {ai}\n"
        prompt_with_history += f"Human: {full_query}\nAI:"

        response = model.generate_content(prompt_with_history)
        bot_response = response.text

        chat_history.append((user_message, bot_response))
        return bot_response

    except Exception as e:
        return f"An error occurred: {e}. Please try again or rephrase your query."

def upload_document(file):
    """Handles document upload and sets the global document context."""
    global document_context
    if file is None:
        document_context = ""
        return "No document uploaded. Chatbot will respond without document context."

    file_path = file.name

    try:
        content = get_document_context(file_path)
        if content.startswith("Error") or content.startswith("Unsupported"):
            document_context = ""
            return content
        else:
            document_context = content
            return "Document uploaded and processed successfully! You can now ask questions related to its content."
    except Exception as e:
        document_context = ""
        return f"Failed to process document: {e}"

def reset_chat():
    """Resets the chat history and document context."""
    global chat_history
    global document_context
    chat_history = []
    document_context = ""
    return "", []

with gr.Blocks(theme=gr.themes.Soft()) as demo:
    gr.Markdown(
        """
        # ðŸ¤– QuizzyBot - QuizITT.com
        Your smart assistant for study queries, QnA, FAQs, and problem-solving at QuizITT.com!
        """
    )

    with gr.Column():
        chatbot = gr.Chatbot(height=400, avatar_images=(None, "cbb.jpg"))
        msg = gr.Textbox(label="Your message", placeholder="Ask a question or start a chat...")
        with gr.Row():
            send_button = gr.Button("Send")
            clear_chat_button = gr.Button("Clear Chat")

        gr.Markdown("---")
        gr.Markdown("## Document Upload")
        file_upload = gr.File(
            label="Upload Document",
            type="filepath",
            file_types=[".txt", ".docx", ".pptx", ".pdf", ".jpg", ".jpeg", ".png", ".img"]
        )
        upload_status = gr.Textbox(label="Upload Status", interactive=False)
        with gr.Row():
            upload_button = gr.Button("Process Document")
            clear_doc_button = gr.Button("Clear Document Context")

    upload_button.click(
        fn=upload_document,
        inputs=file_upload,
        outputs=upload_status
    )
    clear_doc_button.click(
        fn=lambda: (None, "Document context cleared."),
        inputs=[],
        outputs=[file_upload, upload_status]
    )

    def respond_and_update_chat(message, history):
        bot_message = generate_response(message, history)
        history.append((message, bot_message))
        return "", history

    msg.submit(
        fn=respond_and_update_chat,
        inputs=[msg, chatbot],
        outputs=[msg, chatbot]
    )
    send_button.click(
        fn=respond_and_update_chat,
        inputs=[msg, chatbot],
        outputs=[msg, chatbot]
    )

    clear_chat_button.click(
        fn=reset_chat,
        inputs=[],
        outputs=[msg, chatbot]
    )

demo.launch(debug=True, share=True)